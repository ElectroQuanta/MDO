%
\section{RDBMS}
\label{sec:rdbms}
A database is a collection of data, typically describing the activities of one
or more related organizations. For example, a university database might contain
information about the following~\cite{ramakrishnan2003database}:
\begin{item-c}
\item \emph{Entities}: such as students, faculty, courses and classrooms
\item \emph{Relationships} between entities: such as students' enrollment in
  courses, faculty teaching courses, and the use of rooms for courses.
\end{item-c}

An \acrfull{dbms} is a software designed to assist in maintaining and utilizing
large collections of data.
\acrfull{rdbms} is a subset of \gls{dbms} with relationship between tables (entities)
and rows (entities' attributes). It follows the relational model, introduced by E.F. Codd in 1970~\cite{ramakrishnan2003database},
instead of navigational model, where in the data is stored in multiple tables.
The tables are related to each other
using primary and foreign keys. It is the most used database model widely used
by enterprises and developers for storing complex and huge amounts of
data~\cite{rdbmsDbmsDiff}. Some examples of \gls{rdbms} are Oracle Database,
MySQL, IBM DB2, SQLite, PostgreSQL, and MariaDB.

From the users' application standpoint, a \gls{rdbms} is a management system
for databases, but is useless unless it provides an efficient and easy method to
pose questions involving the data stored in the databases. These questions are
called queries~\cite{ramakrishnan2003database}.
A \gls{dbms} provides a
specialized language --- query language --- in which queries can be performed.
The \gls{sql} for relational databases, is now the standard.
Arguably, the most widely used form
of concurrent programming is the concurrent execution of database programs
(called transactions). Users write programs as if they are to be run by
themselves, and the responsibility for running them concurrently is given to the
\gls{dbms}~\cite{ramakrishnan2003database}.

In this section an overview is presented about \gls{rdbms} foundations:
description and storage of data in a \gls{dbms}, relational model, levels of abstraction in a \gls{dbms}, transaction management,
and the structure of a \gls{dbms}. Additionally, a brief overview over \gls{sql}
and a C++ interface is presented.

\subsection{Description and storage of data in a DBMS}
\label{sec:descr-stor-data}
The user of a \gls{dbms} is ultimately concerned about the description of
various aspects of some real-world enterprise in the form of data. There are two
important data models used~\cite{ramakrishnan2003database}:
\begin{item-c}
\item \emph{Data model}: collection of high-level data description constructs
  that hide many low-level storage details. A \gls{dbms} allows a user to define
  the data to be stored in terms of a data model, such as the \textbf{relational
  data model}. It is closer to how the \gls{dbms} stores the data.
\item \emph{Semantic data model}: more abstract, high-level data model, closer
  to human thinking, serving as an useful starting point for the database
  design. The semantic data model is subsequently translated into a database
  design in terms of the data model the \gls{dbms} actually supports.
  An example is the \emph{\acrfull{er}} model which allows the user to
  pictorially denote entities and the relationship among them. The semantic data
\end{item-c}

\subsection{Relational model}
\label{sec:relational-model}
The central data description construct in the relational model is a \emph{relation},
which can be thought as a set of
\emph{records}~\cite{ramakrishnan2003database}.
A \emph{schema} is a description of data in terms of the data model. In the
relation model, the schema for a relation specifies its name, the name of each
\emph{field} (or \emph{attribute} or \emph{column}), and the type of each
field. As an example, student information in a university database may be stored
in a relation with the following schema~\cite{ramakrishnan2003database}:
\begin{quote}
\texttt{Students(\emph{sid}: string, \emph{name}: string, \emph{login}: string, \emph{age}: integer, \emph{gpa}: real)}
\end{quote}
%
The preceding schema states that each record in the Students relation has five
fields, with field names and types as indicated. As example instance of the
student relation appears in Table~\ref{tab:relational-model-example}~\cite{ramakrishnan2003database}.
%
\begingroup
\renewcommand{\arraystretch}{0.9} % Default value: 1
\begin{table}[hbt!]
\centering
\caption{An instance of the students relation --- withdrawn from \cite{ramakrishnan2003database}}
\label{tab:relational-model-example}
\begin{tabular}{@{}lllll@{}}
\toprule
\textbf{sid} & \textbf{name} & \textbf{login} & \textbf{age} & \textbf{gpa} \\ \midrule
53666        & Jones         & jones@cs       & 18           & 3.4          \\
53688        & Smith         & smith@ee       & 18           & 3.2          \\
53650        & Smith         & smith@math     & 19           & 3.8          \\
53831        & Madayan       & madayan@music  & 11           & 1.8          \\
53932        & Guldu         & guldu@music    & 12           & 2.0          \\ \bottomrule
\end{tabular}
\end{table}
\endgroup

Each row in the Students relation is a record that describes a student,
following the schema of the Students relation. Thus, the schema can be thought
as a template for describing a student. This description can be made more
precise by specifying integrity constraints, i.e., the conditions that the
records in a relation must satisfy~\cite{ramakrishnan2003database}.
For example, one could specify that every
student had a unique \texttt{sid} value, thus making a potential candidate for a
primary key, i.e., an unique identifier that univocally identifies each record
in a relation. This information cannot be captured by simply adding another
field to the Students schema, thus requiring integrity constraints to increase
the expressiveness of the constructs of a data model~\cite{ramakrishnan2003database}.

\subsection{Levels of abstraction in a DBMS}
\label{sec:levels-abstr-dbms}
The data in a \gls{dbms} is described at three levels of abstraction, as
illustrated in Fig.~\ref{fig:dbms-abstraction-levels},
namely~\cite{ramakrishnan2003database}:
\begin{item-c}
\item \emph{External schema}: allow data access to be customized (and
  authorized) at the level of individual users or group of users.
  Any given database has exactly one conceptual schema and one
physical schema because it has just one set of stored relations, but it may have
several external schemas, each tailored to a particular group of users.
Each external schema consists of a collection of one or more views and relations
from the conceptual schema.
A \emph{view} is conceptually a relation, but the records in a view are not
stored in the DBMS. Rather, they are computed using a definition for the view,
in terms of relations stored in the DBMS.
\item \emph{Conceptual schema}: also known as the \emph{logical schema},
  describes the stored data in terms of the data model of the \gls{dbms}. In a
  \gls{rdbms}, the conceptual schema describes all relations that are stored in
  the database. The conceptual schema may be design using the \gls{er} model.
\item \emph{Physical schema}: translates how the relations described in the
  conceptual schema are actually stored on secondary storage devices such as
  disks and tapes. Decisions about the physical schema are based on the
  understanding of how the data is typically accessed, typically requiring the
  design to decide about the file organizations used to store the relations and
  to create auxiliary data structures called \emph{indexes} to speed up data
  retrieval operations.
\end{item-c}
%
\begin{figure}[htb!]
\centering
    \includegraphics[width=0.65\columnwidth]{./img/dbms-abstraction-levels.png}
  \caption{Levels of abstraction in a DBMS (withdrawn from~\cite{ramakrishnan2003database})}%
\label{fig:dbms-abstraction-levels}
\end{figure}
%
\subsection{Transaction management}
\label{sec:trans-manag}
An important task of a \gls{dbms} is to schedule concurrent accesses to data in
a safe and seamless way to the user. Such accesses are named
\emph{transactions}, i.e., any one execution of a user program in a \gls{dbms},
corresponding to the basic unit of change as seen by the \gls{dbms}. Partial
transactions are not allowed, and the effect of a group of transactions is
equivalent to some serial execution of all transactions~\cite{ramakrishnan2003database}.

For the concurrent execution of transactions to take place, a \emph{locking
  protocol} is enforced by the \gls{dbms}, establishing a set of rules to be
followed by each transaction, using a \emph{lock} --- a mechanism to control
access to database objects.
Two kinds of locks are commonly supported by a DBMS: \emph{shared locks} on an
object can be held by two different transactions at the same time, but an
\emph{exclusive lock} on an object ensures that no other transactions hold any
lock on this object~\cite{ramakrishnan2003database}.

Transactions can be interrupted before running to completion for a variety of
reasons, e.g., a system crash. A DBMS must ensure that the changes made by such
incomplete transactions are removed from the database. To do so, the DBMS
maintains a log of all writes to the database, even before
the corresponding change is reflected in the database itself, enabling the
\gls{dbms} to detect and undo the changes if a system crash occurs. This property is called \gls{wal}. To ensure this property, the
DBMS must be able to selectively force a page in memory to disk~\cite{ramakrishnan2003database}.

The log is also used to ensure that the changes made by a successfully completed
transaction are not lost due to a system crash, as explained. Bringing
the database to a consistent state after a system crash can be a slow process,
since the DBMS must ensure that the effects of all transactions that completed
prior to the crash are restored, and that the effects of incomplete transactions
are undone. The time required to recover from a crash can be reduced by
periodically forcing some information to disk; this periodic operation is called a \emph{checkpoint}~\cite{ramakrishnan2003database}.

Summarizing, the main takeaways for \gls{dbms} support for concurrency control
and recovery are~\cite{ramakrishnan2003database}:
\begin{item-c}
\item \emph{Locking}:
every object that is read or written by a transaction is first locked in shared
or exclusive mode, respectively. Placing a lock on an object restricts its
availability to other transactions and thereby affects performance.
\item \emph{\gls{wal}}: for efficient log maintenance, the DBMS must be able to
  selectively force a collection of pages in main memory to disk. \gls{os}
  support for this operation is not always satisfactory.
\item \emph{Periodic checkpoint}:
  can reduce the time needed to recover from a crash. There is a trade-off
  between speed and system integrity, as checkpointing too often slows
  down normal execution. 
\end{item-c}
%
\subsection{Structure of a RDBMS}
\label{sec:structure-rdbms}

Fig.~\ref{fig:dbms-abstraction-levels} shows the structure (with some
simplification) of a typical \gls{dbms} based on the relational data model.
%
\begin{figure}[htb!]
\centering
    \includegraphics[width=0.75\columnwidth]{./img/dbms-struct.png}
  \caption{Architecure of a DBMS (withdrawn from~\cite{ramakrishnan2003database})}%
\label{fig:dbms-abstraction-levels}
\end{figure}
%

It is comprised of~\cite{ramakrishnan2003database}: 
\begin{item-c}
\item \emph{Interfaces}:
  The DBMS accepts \gls{sql} commands generated from a
  variety of user interfaces, produces query evaluation plans, executes these
  plans against the database, and returns the answers. SQL commands can also be
  embedded in host-language application programs, e.g., Java or C++ programs,
  but here one concentrates only on the core DBMS functionality.
\item \emph{\gls{dbms}}: contains:
  \begin{itemize}
  \item \emph{Query Evaluation Engine}:
    When a user issues a query, the parsed query is presented to a query
    optimizer, which uses information about how the data is stored to produce an
    efficient execution plan for evaluating the query. An execution plan is a
    blueprint for evaluating a query, and is usually represented as a tree of
    relational operators (with annotations that contain additional detailed
    information about which access methods to use, etc.).
  \item \emph{Concurrency control}:
  The \emph{Transaction Manager} ensures that transactions request and release
  locks according to a suitable locking protocol and schedules the execution
  transactions.
%
  The \emph{Lock Manager} keeps tracks of request for locks and grants locks on
  database objects when they become available.
 % 
  \item \emph{Recovery manager}:
    responsible for maintaining a log, and restoring the system to a consistent
    state after a crash.
  \item \emph{Disk access manager}:
    The \emph{file and access methods} layer includes a variety of software for
    supporting the concept of a file, which, in a DBMS, is a collection of pages
    or a collection of records. This layer typically supports a heap file, or
    file of unordered pages, as well as indexes.
    In addition to keeping track of the pages in a file, this layer organizes
    the information within a page.
%
    The \emph{Buffer manager} handles pages as a response to read requests.
%   
    The \emph{disk space manager} deals with management of space on
    disk, where the data is stored. Higher layers allocate, deallocate, read,
    and write pages through (routines provided by) this layer.
  \end{itemize}
\item \emph{Database}: contains the system catalog information consisting of the
  index files referencing the data files storing the actual data on physical
  memory.
\end{item-c}

\subsection{Entity-Relationshiop model}
\label{sec:entity-relat-model}


\subsection{SQL}
\label{sec:sql}

\subsection{SQL C++ interface}
\label{sec:sql-c++-interface}





%% Local Variables:
%% mode: latex
%% TeX-master: "../../../dissertation"
%% End:

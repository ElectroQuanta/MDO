%
\section{Build system and Makefiles}
\label{sec:make-makefiles}
\texttt{Make} is essentially a dependency-tracking build utility, which is most
commonly used as a build automation tool to generate executable programs and
libraries from source code by reading files called \texttt{Makefiles}. These
files specify how to derive the target program, defining the prerequisites
(dependencies) and the rule for generating
it~\cite{stallman2002gnu}. Nonetheless, the
\texttt{Make} utility is also used as automation build tool for compiling
\texttt{LaTeX} documents or to manage the workflow of data analysis projects~\cite{baker2020using}.

\texttt{Make} was originally created by Stuart Feldman in April 1976 at Bell
Labs, after the experience of a coworker in futilely debugging a program of his where the executable was accidentally not being updated with changes~\cite{raymond2003art}:
\begin{quote}
  %\textsl{%
    `\texttt{Make} originated with a visit from Steve Johnson (author of yacc, etc.),
    storming into my office, cursing the Fates that had caused him to waste a
    morning debugging a correct program (bug had been fixed, file hadn't been
    compiled, \texttt{cc *.o} was therefore unaffected).
    As I had spent a part of the
    previous evening coping with the same disaster on a project I was working
    on, the idea of a tool to solve it came up. It began with an elaborate idea
    of a dependency analyzer, boiled down to something much simpler, and turned
    into Make that weekend. Use of tools that were still wet was part of the
    culture. Makefiles were text files, not magically encoded binaries, because
    that was the Unix ethos: printable, debuggable, understandable stuff.'
  %}
    
     --- Stuart Feldman, The Art of Unix Programming, Eric S. Raymond 2003
\end{quote}

Before \texttt{Make}'s introduction, the Unix build system most commonly
consisted of \gls{os} dependent \texttt{make} and \texttt{install} shell scripts
accompanying their program's source code.
\texttt{Make} enabled the combination of commands for the different targets into
a single file and to abstract out dependency tracking and archive handling,
making it a cornerstone to pave the way for modern build environments.

Several versions of the \texttt{Make} utility were implemented, by porting them
into different OSes or by rewriting from scratch, like the \texttt{BSD Make}
(\gls{bsd} systems),
\texttt{GNU make} (Linux and MacOS) or \texttt{nmake} (Windows). The \texttt{GNU
make} is the standard implementation for Linux-- and MacOS--based systems~\cite{robbins2005unix}, and,
thus, it will the one being addressed here.

The GNU implementation of \texttt{make} --- written by Richard Stallman and
Roland McGrath ~\cite{stallman2002gnu}--- tracks down the targets that need to
be recompiled and executes the defined commands in the \texttt{makefile}
containing the rules for those targets. If the flag \texttt{-f} is not provided
to \texttt{make}, it will look for makefiles \texttt{GNUmakefile} (not
recommended --- only if the file is specific to \texttt{GNU make}),
\texttt{makefile}, and \texttt{Makefile} in that
order~\cite{stallman2002gnu}. \emph{make} will then update the target if it
depends on prerequisite files that have been modified since the target was last
modified, or if the target does not exit.

\subsection{Makefile syntax and example}
\label{sec:makef-synt-example}
A simple \texttt{makefile} consists of rules with the following
shape~\cite{stallman2002gnu}:
\begin{quote}
\begin{verbatim}
target ... : prerequisites ...
<TAB>recipe
<TAB>...
<TAB>...
\end{verbatim}
\end{quote}
%
The basic syntax can be explained as follows~\cite{stallman2002gnu}:
\begin{item-c}
\item \emph{\texttt{target}}:
it is usually the name of a file that is generated by a program; examples
of targets are executable or object files. A target can also be the name of an
action to carry out, such as \texttt{clean}, being named as \emph{phony targets}. 
\item \emph{\texttt{prerequisite}}:
file that is used as input to create the target. A target
often depends on several files.
\item \emph{\texttt{recipe}}:
it is an action that make carries out. A recipe may have more than one command,
either on the same line or each on its own line. A \texttt{tab} character is
required at the beginning of every recipe line.

Usually a recipe is in a rule with prerequisites and serves to create a target
file if any of the prerequisites change.
However, the rule that specifies a recipe for the target need not
have prerequisites. For example, the rule containing the delete command
associated with the target \texttt{clean} does not have prerequisites.
\item \emph{\texttt{rule}}:
explains how and when to remake certain files which are the targets of
the particular rule. \texttt{make} carries out the recipe on the prerequisites to create or update
the target. A rule can also explain how and when to carry out an action.
\end{item-c}

Listing~\ref{lst:makefile-example} presents an \texttt{Makefile} example, with a
preamble documenting the syntax for easier comprehension (lines 1 through 51). Line 54 defines the
project name by assigning it to a variable \texttt{PROJ}. Line 57 and 58 define
the file paths for source code and binaries using macro expansion. Line 61
defines the compilation flags --- \texttt{CFLAGS} --- which is known makefile
variable. Line 62 defines the command \texttt{RM} to remove files and folders
recursively. Lines 65 and 66 define the \texttt{Doxygen} documentation
paths. Lines 69 and 71 retrieve database and C-source files by using the
wildcard expansion which matches the patterns (globs) defined after. Lines 74
through 79 exemplify the usage of conditionals to add different compilation
flags. Line 81 comment shows a bad practice, which is to define the \texttt{CC}
variable --- \texttt{C Compiler} --- to a specific compiler, thus, making it not
portable. The alternative is to set the \texttt{CC} outside of the
\texttt{makefile}. Line 83 finalizes the initialization part of the makefile by
performing pattern substitution to obtain all object files from
\texttt{C}-source files.

Line 86 starts the rules part of the makefile, defining the default rule and stating that to build
\texttt{\$(PROJ)} executable it is required the object files (\texttt{\$(OBJ)}) and one
can compile it using the \texttt{C compiler}, the dependencies and the required
libraries. When \texttt{make} tries to evaluate the dependency list, if the
object files haven't been produced yet, it will generate them using the rule
from line 95 and then it can execute rule \texttt{\$(PROJ)}.

Line 101 states that calling \texttt{make all} will invoke the default rule and
echo `\texttt{Compiling project}'.

Line 105 states that calling \texttt{make install} will invoke the \texttt{all}
and \texttt{clean} rules to compile the application and install the binaries at
the appropriate location.

Line 111 contains the phony targets, i.e., targets whose names represent actions
like \texttt{clean}, \texttt{mrproper}, \texttt{clean-all}, and \texttt{doc}:
\texttt{clean} removes all objects files, \texttt{mrproper} and
\texttt{clean-all} will remove also the executable file generated, and
\texttt{doc} will generate the documentation using \texttt{Doxygen}.
%
\lstinputlisting[
language={[gnu] make},
%firstline=1, lastline=3,%
caption={Makefile example},
label=lst:makefile-example,
style=makefile]{./listing/makefile_example}

\subsection{Other build systems for C/C++}
\label{sec:other-build-systems}
\texttt{Make} is just part of the simplest building system for C/C++. But there
are other ones which are noteworthy\cite{c++buildSystems}:
\begin{item-c}
\item \emph{\texttt{Autotools}} --- \texttt{Automake} and \texttt{Autoconf}:
In 1991, David J. MacKenzie got tired of customizing Makefile for the 20
platforms he had to deal with. Instead, he handcrafted a little shell script
called \texttt{configure} to automatically adjust the Makefile.
Compiling his package was now as simple as running \texttt{./configure \&\&
  make}~\cite{automakeManual}. The Autotools are tools that will create a GNU Build System for your
package. Autoconf mostly focuses on \texttt{configure} and \texttt{automake} on Makefiles.

Simply put, \texttt{automake} aims to allow the programmer to write a makefile
in a higher-level language, rather than having to write the whole makefile
manually.
%In simple cases, it is sufficient to provide:
%\begin{item-c}
%\item 
%    a line that declares the name of the program to build;
%\item 
%    a list of source files;
%\item 
%    a list of command-line options to be passed to the compiler (for example, in which directories header files will be found);
%\item 
%    a list of command-line options to be passed to the linker (which libraries the program needs and in what directories they are to be found);
%\end{item-c}
However, the system is very complex and has a steep learning curve.
\item \emph{\texttt{CMake}}:
CMake reads the projects to build from \texttt{CMakeLists.txt} files written in a language of its own. From there it generates some Makefiles (or equivalent project files for Xcode or Visual Studio for example) that can be used to build the project.

The main criticism against CMake is its language, requiring another syntax to be
learned and that it generates of lot of intermediate files.
\end{item-c}
%
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../../dissertation"
%%% End:

%
\section{Concurrency}%
\label{sec:concurrency}
Concurrency is used to refer to things that appear to happen at the same time,
but which may occur serially~\cite{buttlar1996pthreads}, like the case of a
multithreaded execution in a single processor system.
Two concurrent tasks may start, execute and finish in overlapping instants of
time, without the two being executed at the same time.
As defined by the \gls{posix} specification, a concurrent execution requires that a function that
suspends the calling thread shall not suspend other threads, indefinitely.

This concept is different from parallelism. Parallelism refers to the
simultaneous execution of tasks, like the one of a multithreaded program in a
multiprocessor system.
Two parallel tasks are executed at the same time and, as such, they require
the execution in exclusivity in independent processors.

Every concurrent system provides three important facilities~\cite{buttlar1996pthreads}:
\begin{item-c}
\item \textbf{Execution Context}: refers to the concurrent entity state. It
  allows the context switch and it must maintain the entities states,
  independently.
\item \textbf{Scheduling}: in a concurrent system, the scheduling decides what
  context should execute at any given time.
\item \textbf{Synchronization}: this allows the management of shared resources
  between the concurrent execution contexts.
\end{item-c}

\section{Threads versus Processes}
\label{sec:threads-vs-processes}
Threads and processes are two mechanisms to design an application to perform
multiple tasks concurrently. A single process can contain multiple threads.
In this section, it is briefly presented some of the factors that might
influence the choice of whether to implement an application as a group of
threads or as a group of processes.

The advantages of a multithreaded approach are~\cite{kerrisk2010linux}:
\begin{item-c}
\item \emph{Data sharing}: Sharing data between threads is easy, as all of them
  share the same data and heap address spaces. By contrast, sharing data between
  processes requires the usage of an \gls{ipc} mechanism.
\item \emph{Context switching}: Thread creation is faster than process creation;
  context-switch time may be lower for threads than for processes.
\end{item-c}


Using threads can have some disadvantages compared to using
processes~\cite{kerrisk2010linux}:
\begin{item-c}
\item  \emph{Thread safety}: When programming with threads, one needs to ensure
  that the functions we call are thread-safe, i.e., can be invoked by multiple
  threads at the same time. Multiprocess applications don't need to be concerned
  with this.
\item \emph{Isolation}: A bug in one thread (e.g., modifying memory via an
  incorrect pointer) can damage all of the threads in the process, since they
  share the same address space and other attributes. By contrast, processes are
  more isolated from one another.
\item \emph{Memory usage}: Each thread is competing for use of the finite
  virtual address space of the host process. In particular, each thread’s stack
  and thread-specific data (or thread-local storage) consumes a part of the
  process virtual address space, which is consequently unavailable for other
  threads. Although the available virtual address space is large, this factor
  may be a significant limitation for processes employing large numbers of
  threads or threads that require large amounts of memory.
  By contrast, separate processes can each employ the full range of available
  virtual memory (subject to the limitations of RAM and swap space).
\end{item-c}

Summarizing, the key factors to consider when designing a concurrent application
(multithread or multiprocess) are~\cite{kerrisk2010linux}:
\begin{item-c}
\item In a multithreaded process, multiple threads are concurrently executing
  the same program. All of the threads share the same global and heap variables,
  but each thread has a private stack for local variables. The threads in a
  process also share a number of other attributes, including process ID, open
  file descriptors, signal dispositions, current working directory, and resource
  limits.
\item The key difference between threads and processes is the easier sharing of
information that threads provide, and this is the main reason that some
application designs map better onto a multithread design than onto a
multiprocess design.
\item Threads can also provide better performance for some operations (e.g.,
  thread creation is faster than process creation), but this factor is usually
  secondary in influencing the choice of threads versus processes.
\end{item-c}

\subsection{Pthreads API}
\label{sec:pthreads-api}
In the late 1980s and early 1990s, several different threading \gls{api}s
existed. Thus, a standard and portable implementation was required, leading to
standardization of the \gls{posix} threads API --- Pthreads --- by the POSIX.1c
in 1995~\cite{kerrisk2010linux}.

Pthreads is a standardized model for dividing a program into subtasks whose
execution can be interleaved or run in parallel~\cite{buttlar1996pthreads}.

\subsubsection{Thread creation}
\label{sec:thread-creation}
When a program is started, the resulting process consists of a single thread,
called the initial or main thread. Additional threads can be created using the
function \texttt{pthread\_create()}~\cite{kerrisk2010linux}:
\lstinputlisting[language=c,firstline=1, lastline=3,
caption={},
%label=lst:kf-main-short,
style=customc]{./listing/pthreads_api.c}
% 
%\begin{lstlisting}[language=C,
%%caption={Hello},label=lst:kf-main-short,
%style=customc, mathescape=true]
%#include <pthread.h>
%int pthread_create(pthread_t *thread, const pthread_attr_t *attr,
%                   void *(*start)(void*), void *arg);
%\end{lstlisting}
%
This function takes as arguments a pointer to a buffer of type
\texttt{pthread\_t} --- into which the unique identifier for this thread is
copied (thread ID) before \texttt{pthread\_create()} returns, the thread attributes, a function pointer containing
the so called \texttt{worker} function, and the \texttt{worker} function
arguments.

The new thread then starts execution by calling the function
identified by \texttt{start} with the argument \texttt{arg} (i.e,
\texttt{start(args)}). The thread that calls \texttt{pthread\_create()}
continues execution with the next statement that follows the call. The
\texttt{arg} argument is declared as \texttt{void *}, allowing generic data to
be passed to the \texttt{worker} function. This function returns \texttt{0} on
success, or a positive number indicating the error occurred. 
%
\subsubsection{Thread termination}
\label{sec:thread-termination}
The execution of a thread terminates in one of the following
ways~\cite{kerrisk2010linux}:
\begin{item-c}
\item the thread's worker function performs a \texttt{return} specifying a
  return value for the thread;
\item the thread calls \texttt{pthread\_exit()};
\item the thread is canceled using \texttt{pthread\_cancel()};
\item any of the thread calls \texttt{exit()}, or the main thread performs a
  return, causing all threads in the process to terminate immediately.
\end{item-c}

The \texttt{pthread\_exit()} function terminates the calling thread and returns a
value via \texttt{retval} that is available to another thread in the same
process that calls \texttt{pthread\_join()}.
\lstinputlisting[language=c,firstline=5, lastline=6,
caption={},
%label=lst:kf-main-short,
style=customc]{./listing/pthreads_api.c}

\subsubsection{Joining with a terminated thread}
\label{sec:join-with-term}
The \texttt{pthread\_join()} function waits for the thread identified by
\texttt{thread} to terminate~\cite{kerrisk2010linux}.
%
\lstinputlisting[language=c,firstline=8, lastline=9,
caption={},
%label=lst:kf-main-short,
style=customc]{./listing/pthreads_api.c}
%
It is important to note that:
\begin{item-c}
\item if the thread has already terminated, \texttt{pthread\_join()} returns
  immediately;
\item calling \texttt{pthread\_join()} for ta thread ID that has been previously
  joined can lead to unpredictable behavior;
\item if a thread is not detached, it must be joined with
  \texttt{pthread\_join()}, otherwise it produces a `zombie' thread, wasting
  system resources.
\end{item-c}

\subsubsection{Detaching a thread}
\label{sec:detaching-thread}
By default, a thread is joinable, meaning that when it terminates, another
thread can obtain its return status using \texttt{pthread\_join()}.
Sometimes, the thread’s return status is irrelevant: one simply wants the system
to automatically clean up and remove the thread when it terminates.
In this case, the thread can be detached,
by making a call to \texttt{pthread\_detach()} specifying the thread’s identifier in thread~\cite{kerrisk2010linux}.
%
\lstinputlisting[language=c,firstline=11, lastline=12,
caption={},
%label=lst:kf-main-short,
style=customc]{./listing/pthreads_api.c}
Once a thread has been detached, it is no longer possible to use \texttt{pthread\_join()}
to obtain its return status, and the thread can't be made joinable again.
Another important note is that \texttt{pthread\_detach()} only controls what
happens after a thread terminates, not how or when it terminates. If another
thread calls \texttt{exit()} or the main thread returns, 
all threads in the process are immediately terminated, regardless of whether they are joinable or detached.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../../dissertation"
%%% End:

%
\section{Concurrency}%
\label{sec:concurrency}
Concurrency is used to refer to things that appear to happen at the same time,
but which may occur serially~\cite{buttlar1996pthreads}, like the case of a
multithreaded execution in a single processor system.
Two concurrent tasks may start, execute and finish in overlapping instants of
time, without the two being executed at the same time.
As defined by the \gls{posix} specification, a concurrent execution requires that a function that
suspends the calling thread shall not suspend other threads, indefinitely.

This concept is different from parallelism. Parallelism refers to the
simultaneous execution of tasks, like the one of a multithreaded program in a
multiprocessor system.
Two parallel tasks are executed at the same time and, as such, they require
the execution in exclusivity in independent processors.

Every concurrent system provides three important facilities~\cite{buttlar1996pthreads}:
\begin{item-c}
\item \textbf{Execution Context}: refers to the concurrent entity state. It
  allows the context switch and it must maintain the entities states,
  independently.
\item \textbf{Scheduling}: in a concurrent system, the scheduling decides what
  context should execute at any given time.
\item \textbf{Synchronization}: this allows the management of shared resources
  between the concurrent execution contexts.
\end{item-c}

\section{Threads versus Processes}
\label{sec:threads-vs-processes}
Threads and processes are two mechanisms to design an application to perform
multiple tasks concurrently. A single process can contain multiple threads.
In this section, it is briefly presented some of the factors that might
influence the choice of whether to implement an application as a group of
threads or as a group of processes.

The advantages of a multithreaded approach are~\cite{kerrisk2010linux}:
\begin{item-c}
\item \emph{Data sharing}: Sharing data between threads is easy, as all of them
  share the same data and heap address spaces. By contrast, sharing data between
  processes requires the usage of an \gls{ipc} mechanism.
\item \emph{Context switching}: Thread creation is faster than process creation;
  context-switch time may be lower for threads than for processes.
\end{item-c}


Using threads can have some disadvantages compared to using
processes~\cite{kerrisk2010linux}:
\begin{item-c}
\item  \emph{Thread safety}: When programming with threads, one needs to ensure
  that the functions we call are thread-safe, i.e., can be invoked by multiple
  threads at the same time. Multiprocess applications don't need to be concerned
  with this.
\item \emph{Isolation}: A bug in one thread (e.g., modifying memory via an
  incorrect pointer) can damage all of the threads in the process, since they
  share the same address space and other attributes. By contrast, processes are
  more isolated from one another.
\item \emph{Memory usage}: Each thread is competing for use of the finite
  virtual address space of the host process. In particular, each threadâ€™s stack
  and thread-specific data (or thread-local storage) consumes a part of the
  process virtual address space, which is consequently unavailable for other
  threads. Although the available virtual address space is large, this factor
  may be a significant limitation for processes employing large numbers of
  threads or threads that require large amounts of memory.
  By contrast, separate processes can each employ the full range of available
  virtual memory (subject to the limitations of RAM and swap space).
\end{item-c}

Summarizing, the key factors to consider when designing a concurrent application
(multithread or multiprocess) are~\cite{kerrisk2010linux}:
\begin{item-c}
\item In a multithreaded process, multiple threads are concurrently executing
  the same program. All of the threads share the same global and heap variables,
  but each thread has a private stack for local variables. The threads in a
  process also share a number of other attributes, including process ID, open
  file descriptors, signal dispositions, current working directory, and resource
  limits.
\item The key difference between threads and processes is the easier sharing of
information that threads provide, and this is the main reason that some
application designs map better onto a multithread design than onto a
multiprocess design.
\item Threads can also provide better performance for some operations (e.g.,
  thread creation is faster than process creation), but this factor is usually
  secondary in influencing the choice of threads versus processes.
\end{item-c}

\subsection{Pthreads API}
\label{sec:pthreads-api}
In the late 1980s and early 1990s, several different threading \gls{api}s
existed. Thus, a standard and portable implementation was required, leading to
standardization of the \gls{posix} threads API --- Pthreads --- by the POSIX.1c
in 1995~\cite{kerrisk2010linux}.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../../dissertation"
%%% End:
